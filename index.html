<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>RDF* and SPARQL*</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
   // All config options at https://respec.org/docs/
   var respecConfig = {
      specStatus: "CG-DRAFT",
      editors: [
        {
          "name": "Olaf Hartig",
          "url": "https://olafhartig.de/",
          "company": "Linköping University",
          "orcid": "0000-0002-1741-2090",
          "companyURL": "https://liu.se/",
        },{
          "name":       "Pierre-Antoine Champin",
          "url":        "http://champin.net/",
          "company":    "ERCIM",
          "companyURL": "https://www.ercim.eu/",
          "w3cid":      42931,
          "orcid": "0000-0001-7046-4474",
        },
      ],
      authors: [
      {
          "name": "Dörthe Arndt",
          "company": "Ghent University",
        },
        {
          "name": "Bryan Thompson",
          "company": "Amazon",
        },
      ],
      github: "w3c/rdf-star",
      shortName: "rdf-star",
      group: "rdf-dev",
      xref: ["RDF11-CONCEPTS", "SPARQL11-QUERY", "RDF11-MT"],
      maxTocLevel: 2,
    };
  </script>
  <style>
    /* copied from TR/turtle, and adapted for SPARQL rules */
    .grammar td { font-family: monospace; vertical-align: top; }
    .grammar-literal, .token { color: gray;}
    .grammar_comment { color: #A52A2A; font-style: italic; }
  </style>
  <script>
    /* copied from JSON-LD specs */
    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(reindent(unComment(doc, content)));
    }

    function _esc(s) {
      return s.replace(/&/g,'&amp;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;');
    }

    function reindent(text) {
      // TODO: use trimEnd when Edge supports it
      const lines = text.trimRight().split("\n");
      while (lines.length && !lines[0].trim()) {
        lines.shift();
      }
      const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
      const leastIndent = Math.min(...indents);
      return lines.map(s => s.slice(leastIndent)).join("\n");
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
        .replace(/-->/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }
  </script>
</head>
<body>
  <section id="abstract">
    <p>TODO</p>
  </section>
  <section id="sotd">
  </section>

  <section id="introduction">
    <h1>Introduction</h1>

    <section class="informative">
      <h2>Background and Motivation</h2>

      <p>TODO, citing [[RDF-STAR-FOUNDATION]]</p>
    </section>

    <section class="informative">
      <h2>Overview</h2>

      <p>TODO (the purpose of this section will be to provide an informal introduction to the approach for practitioners)</p>
      <p>The syntax of RDF is defined in two layers:</p>
      <ul>
        <li>the <dfn>abstract syntax</dfn>, which is the conceptual data model of RDF, and</li>
        <li>multiple <dfn data-cite="RDF11-CONCEPTS#dfn-concrete-rdf-syntax" data-lt="concrete syntax|concrete RDF syntax|concrete RDF syntaxes">concrete syntaxes</dfn> (such as RDF/XML [[RDF-SYNTAX-GRAMMAR]], Turtle [[TURTLE]] or JSON-LD [[JSON-LD11]]), which are data formats used to serialize the abstract syntax into files or over the wire.</li>
      </ul>
      <p>Similarly, this document defines the <a>abstract syntax</a> of RDF* in <a href="#concepts"></a>, and one <a>concrete syntax</a> based on Turtle [[TURTLE]] in <a href="#turtle-star"></a>.</p>
    </section>

    <section id="conformance">
      <div class=issue data-number="3"></div>
    </section>

  </section>

  <section id="concepts">
    <h2>Concepts and Abstract Syntax</h2>

    <p>An <dfn data-lt="graph">RDF* graph</dfn> is a set of <a>RDF* triples</a>.</p>

    <p>An <dfn data-lt="triple">RDF* triple</dfn> is a 3-tuple defined recursively as follows:</p>
    <ul>
      <li>any <a>RDF triple</a> is an <a>RDF* triple</a>;</li>
      <li>if |t| and <var>t'</var> are <a>RDF* triples</a>, |s| is an <a>IRI</a> or a <a>blank node</a>, |p| is an <a>IRI</a>, |o| is an <a>IRI</a>, a <a>blank node</a> or a <a>literal</a>, then (|t|, |p|, |o|), (|s|, |p|, |t|) and (|t|, |p|, <var>t'</var>) are <a>RDF* triples</a>.</li>
    </ul>

    <p>As for <a>RDF triples</a>, we call the 3 components of an <a>RDF* triple</a> its <dfn data-cite="RDF11-CONCEPTS#dfn-subject">subject</dfn>, <dfn data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</dfn> and <dfn data-cite="RDF11-CONCEPTS#dfn-object">object</dfn>, respectively. From the definitions above, it follows that any <a>RDF graph</a> is also an <a>RDF* graph</a>.</p>

    <!-- the paragraph below is totally uninformative, but the "foreign" dfn are required-->
    <p style="display: none">The definition relies on the notions of
      <dfn data-cite="RDF11-CONCEPTS#dfn-iri">IRI</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-literal">literal</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-triple">RDF triple</dfn>,
      and <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-graph">RDF graph</dfn>,
      introduced by [[[RDF11-CONCEPTS]]] [[RDF11-CONCEPTS]].
    </p>

    <p><a>IRIs</a>, <a>literals</a>, <a>blank nodes</a> and <a>RDF* triples</a> are collectively known as <dfn>RDF* terms</dfn>.</p>

    <p>For every <a>RDF* triple</a> <var>t</var>, we define its <dfn data-lt="constituent">constituent terms</dfn> (or simply constituents) as the set containing its <a>subject</a>, its <a>predicate</a>, its <a>object</a>, plus all the <a>constituent terms</a> of its <a>subject</a> and/or its <a>object</a> if they are themselves <a>RDF* triples</a>. By extension, we define the <a>constituent terms</a> of an <a>RDF* graph</a> to be the union set of the <a>constituent terms</a> of all its triples.</p>

    <div class="example">
      Consider the following <a>RDF* triple</a> (represented in Turtle*):
      <pre data-transform="updateExample"
        data-content-type="text/x-turtle-star"
        class="nohighlight example"
      >
        <!--
        << _:a :name "Alice" >> :statedBy :bob.
        -->
      </pre>
      Its set of <a>constituent terms</a> comprises the <a>IRIs</a> `:name`, `:statedBy`, `:bob`, the <a>blank node</a> `_:a`, the <a>literal</a> `"Alice"`, and the <a>triple</a> `&lt;&lt; _:a :name "Alice" >>`.
    </div>

    <p>An <a>RDF* triple</a> used as the <a>subject</a> or <a>object</a> of another <a>RDF* triple</a> is called an <dfn data-lt="embedded">embedded triple</dfn>. An <a>RDF* triple</a> that is an element of an <a>RDF* graph</a> is called an <dfn data-lt="asserted">asserted triple</dfn>. Note that, in a given <a>RDF* graph</a>, the same <a>triple</a> MAY be both <a>embedded</a> and <a>asserted</a>.</p>

    <p>An <dfn data-lt="dataset">RDF* dataset</dfn> is a collection of <a>RDF* graphs</a>, and comprises:</p>

    <ul>
      <li>Exactly one <dfn data-cite="RDF11-CONCEPTS#dfn-default-graph">default graph</dfn>, being an <a>RDF* graph</a>. The <a>default graph</a> does not have a name and MAY be empty.</li>
      <li>Zero or more <dfn data-cite="RDF11-CONCEPTS#dfn-named-graph">named graphs</dfn>. Each <a>named graph</a> is a pair consisting of an <a>IRI</a> or a <a>blank node</a> (the <dfn data-cite="RDF11-CONCEPTS#dfn-graph-name">graph name</dfn>), and an <a>RDF* graph</a>. <a>Graph names</a> are unique within an <a>RDF* dataset</a>.</li>
    </ul>

    <p>Again, this definition is an extension of the notion of <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-dataset">RDF dataset</dfn>, hence it follows that any <a>RDF dataset</a> is also an <a>RDF* dataset</a>.</p>
  </section>

  <section id="turtle-star">
    <h2>Turtle*</h2>
    <p>In this section, we present Turtle*, an extension of the Turtle format [[TURTLE]] allowing to represent <a>RDF* graphs</a>. For the sake of conciseness, we only describe here the differences between Turtle* and Turtle.</p>

    <section id="turtle-star-grammar">
      <h2>Grammar</h2>
      <p>Turtle* is defined to follow the <a data-cite="TURTLE#h3_sec-grammar-grammar">same grammar</a> as Turtle, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions with the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="grammar-production-subject">
          <td>[10]</td>
          <td>`subject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-object">
          <td>[12]</td>
          <td>`object`</td>
          <td>::=</td>
          <td><a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a  data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a data-cite="TURTLE#grammar-production-blankNodePropertyList">blankNodePropertyList</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embTriple">
          <td>[27]</td>
          <td>`embTriple`</td>
          <td>::=</td>
          <td>
            <code class="grammar-literal">'&lt;&lt;'</code>
            <a href="#grammar-production-embSubject">embSubject</a>
            <a data-cite="TURTLE#grammar-production-verb">verb</a>
            <a href="#grammar-production-embObject">embObject</a>
            <code class="grammar-literal">'&gt;&gt;'</code>
          </td>
        </tr>
        <tr id="grammar-production-embSubject">
          <td>[28]</td>
          <td>`embSubject`</td>
          <td>::=</td>
          <td><a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embObject">
          <td>[29]</td>
          <td>`embObject`</td>
          <td>::=</td>
          <td><a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
      </table>

      <p class="note">The only changes are that <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-object">`object`</a> productions have been extended to accept <a>embedded triples</a>, which are described by the new productions <a href="#grammar-production-embTriple">27</a> to <a href="#grammar-production-embObject">29</a>. Note that <a>embedded triples</a> accept a more restricted range of <a>subject</a> and <a>object</a> expressions than <a>asserted triples</a>.</p>

      <div class="issue" data-number="9"></div>
    </section>

    <section>
      <h2>Parsing</h2>
      <p>A Turtle* parser is similar to a Turtle parser as defined in <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], with an additional item in its state :</p>
      <ul>
        <li id="curObject"><a>RDF* Term</a> |curObject| — The |curObject| is bound to the <a href="#grammar-production-embObject">`embObject`</a> production.</li>
      </ul>
      <p>Additionally, the <a data-cite="TURTLE#curSubject">|curSubject|</a> can be bound to any <a>RDF* term</a> (including a <a>embedded triple</a>).</p>

      <p>A Turtle* document defines an <a>RDF* graph</a> composed of a set of <a>RDF* triples</a>. The <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-embSubject">`embSubject`</a> productions sets the |curSubject|. The <a data-cite="TURTLE#grammar-production-verb">`verb`</a> production sets the <a data-cite="TURTLE#curPredicate">|curPredicate|</a>. The <a href="#grammar-production-embObject">`embObject`</a> productions sets the |curObject|. For each <a href="#grammar-production-object">`object`</a> |N|, an <a>RDF* triple</a> |curSubject| |curPredicate| |N| is generated and added to the <a>RDF* graph</a>.</p>

      <p>Beginning the <a href="#grammar-production-embTriple">`embTriple`</a> production records the |curSubject| and |curPredicate|. Finishing the <a href="#grammar-production-embTriple">`embTriple`</a> production yields the <a>RDF* triple</a> |curSubject| |curPredicate| |curObject| and restores the recorded values of |curSubject| and |curPredicate|.</p>

      <p>All other productions MUST be handled as specified by <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], while still applying the changes above recursively.</p>
    </section>

    <section class="informative">
      <h2>Other Concrete Syntaxes</h2>

      <p>While this document specifies only one <a>concrete syntax</a>, nothing prevents other <a>concrete syntaxes</a> of RDF* to be proposed. In particular, other existing <a>concrete syntaxes</a> for RDF, such as RDF/XML [[RDF-SYNTAX-GRAMMAR]], could be extended to support RDF*. In particular, the N-Triples syntax [[N-TRIPLES]] being a subset of Turtle, an appropriate subset of Turtle* could be defined to extend N-Triples accordingly.</p>
    </section>

  </section>

  <section>
    <h2>SPARQL* Query Language</h2>

    <p>This Section introduces SPARQL*, which is an RDF*-aware extension of the RDF query language SPARQL [[SPARQL11-QUERY]]; i.e., SPARQL* can be used to query RDF* graphs.</p>

    <section>
      <h2>Initial Definitions</h2>

      <p>In the following, we introduce a number of SPARQL* specific definitions, which rely on the following notions, defined in [[[SPARQL11-QUERY]]] [[SPARQL11-QUERY]]: <dfn data-cite="SPARQL11-QUERY#defn_RDFTerm">RDF term</dfn>, <dfn data-cite="SPARQL11-QUERY#defn_QueryVariable" data-lt="variable">query variable</dfn>, <dfn data-cite="SPARQL11-QUERY#defn_TriplePattern">triple pattern</dfn>,
      <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathPattern">property path pattern</dfn>,
      <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathExpr">property path expression</dfn>,
      and <dfn data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</dfn>.</p>

      <p>A <dfn data-lt="triple-star-pattern">SPARQL* triple pattern</dfn> is a 3-tuple that is defined recursively as follows:</p>
      <ol>
        <li>Every SPARQL <a>triple pattern</a> is a SPARQL* triple pattern;
        <li>If |t| and <var>t'</var> are SPARQL* triple patterns, |x| is an <a>RDF term</a> or a <a>query variable</a>, and |p| is an <a>IRI</a> or a <a>query variable</a>, then (|t|,&nbsp;|p|,&nbsp;|x|), (|x|,&nbsp;|p|,&nbsp;|t|), and (|t|,&nbsp;|p|,&nbsp;<var>t'</var>) are SPARQL* triple patterns.
      </ol>

      <p>As for <a>RDF* triples</a>, a <a>SPARQL* triple pattern</a> MUST NOT contain itself.</p>

      <p>A <dfn data-lt="bgp-star|BGP*">SPARQL* basic graph pattern</dfn> (<abbr title="Basic Graph Pattern">BGP</abbr>*) is a set of <a>SPARQL* triple patterns</a>.</p>

      <p>A <dfn data-lt="ppp-star">SPARQL* property path pattern</dfn> is a 3-tuple (|s|,|p|,|o|) where</p>
      <ul>
        <li>|s| is either an <a>RDF term</a>, a <a>query variable</a>, or a <a>SPARQL* triple pattern</a>,
        <li>|p| is a <a>property path expression</a>, and
        <li>|o| is either an <a>RDF term</a>, a <a>query variable</a>, or a <a>SPARQL* triple pattern</a>.
      </ul>

      <div class="issue" data-number="7"></div>

      <p>A <dfn data-lt="solution-star-mapping">SPARQL* solution mapping</dfn> μ is a partial function from the set of all <a>query variables</a> to the union set of all <a>RDF* terms</a>.
      The domain of μ, denoted by dom(μ), is the set of <a>query variables</a> for which μ is defined.</p>

      <p class="note">The notion of a <a>SPARQL* solution mapping</a> extends the notion of a standard SPARQL <a>solution mapping</a>; that is, every SPARQL <a>solution mapping</a> is a <a>SPARQL* solution mapping</a>. However, in contrast to SPARQL <a>solution mappings</a>, <a>SPARQL* solution mappings</a> may map <a>variables</a> also to <a>RDF* triples</a>.</p>

    </section>

    <section id="sparql-star-grammar">
      <h2>Grammar</h2>

      <p>SPARQL* is defined to follow the <a data-cite="SPARQL11-QUERY#sparqlGrammar">same grammar</a> as SPARQL, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions with the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="rBind">
          <td>[60]</td>
          <td>`Bind`</td>
          <td>::=</td>
          <td>
            <code class="token">'BIND'</code>
            <code class="token">'('</code>
            (
              <a data-cite="SPARQL11-QUERY#rExpression">Expression</a> `|`
              <a href="#rEmbTP">EmbTP</a>
            )
            <code class="token">'AS'</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            <code class="token">')'</code>
          </td>
        </tr>
          <tr id="rTriplesSameSubject">
          <td>[75]</td>
          <td>`TriplesSameSubject`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListNotEmpty">PropertyListNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyList">PropertyList</a>
        </td>
        <tr id="rObject">
          <td>[80]</td>
          <td>`Object`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rGraphNode">GraphNode</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rTriplesSameSubjectPath">
          <td>[81]</td>
          <td>`TriplesSameSubjectPath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPath">PropertyListPath</a>
          </td>
        </tr>
        <tr id="rGraphNodePath">
          <td>[105]</td>
          <td>`GraphNodePath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a> `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNodePath">TriplesNodePath</a> `|`
          </td>
        </tr>
        <tr id="rEmbTP">
          <td>[174]</td>
          <td>`EmbTP`</td>
          <td>::=</td>
          <td>
            <code class="token">'&lt;&lt;</code>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <a data-cite="SPARQL11-QUERY#rVerb">Verb</a>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <code class="token">'&gt;&gt;</code>
          </td>
        </tr>
        <tr id="rEmbSubjectOrObject">
          <td>[175]</td>
          <td>`EmbSubjectOrObject`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rBlankNode">BlankNode</a> `|`
            <a data-cite="SPARQL11-QUERY#riri">iri</a> `|`
            <a data-cite="SPARQL11-QUERY#rRDFLiteral">RDFLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rNumericLiteral">NumericLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rBooleanLiteral">BooleanLiteral</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rVarOrTermOrEmbTP">
          <td>[176]</td>
          <td>`VarOrTermOrEmbTP`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rGraphTerm">GraphTerm</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
      </table>

      <p>
        This introduces a notation for <dfn>embedded triple patterns</dfn>
        (productions <a href="#rEmbTP">[174]</a> and following),
        which is similar to the one defined for <a>embedded triples</a> in <a href="#turtle-star"></a>,
        but accepting also <a>variables</a>.
        These <a>embedded triple patterns</a> are allowed in subject
        (<a href="#rTriplesSameSubject">[75]</a>, <a href="#rTriplesSameSubjectPath">[81]</a>)
        and object
        (<a href="#rObject">[80]</a>, <a href="#rGraphNodePath">[105]</a>)
        position of <a>SPARQL* triple patterns</a>,
        as well as in BIND statements
        (<a href="#rBind">[60]</a>).
      </p>

      <div class="issue" data-number="6"></div>

    </section>

    <section>
      <h2>Translation to the Algebra</h2>

      <p>Based on the SPARQL grammar the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> [<a data-cite="SPARQL11-QUERY#sparqlQuery">SPARQL11-QUERY, Section 18.2</a>].  This process must be adjusted to consider the extended grammar introduced <a href="#sparql-star-grammar">above</a>. In the following, any step of the conversion process that requires adjustment is discussed.</p>

      <section>
        <h2>Variable Scope</h2>

        <p>As a basis of the translation, the SPARQL specification introduces a notion of <a data-cite="SPARQL11-QUERY#variableScope">in-scope variables</a>. To cover the new syntax elements introduced in <a href="#sparql-star-grammar"></a> this notion MUST be extended as follows.</p>

        <ul>
          <li>A <a>variable</a> is in-scope of a <a>BGP*</a> |B| if the <a>variable</a> occurs in |B|, which includes an occurrence in any <a>embedded triple pattern</a> in |B| (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a <a>property path pattern</a> if the variable occurs in that pattern, which includes an occurrence in any embedded triple pattern in the pattern (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a BIND clause of the form `BIND ( T AS v )` (where |T| is an <a>embedded triple pattern</a>) if the variable is variable |v| or the variable occurs in the <a>embedded triple pattern</a> |T|. As for standard BIND clauses with expressions, variable |v| must <q>not [be] in-scope from the preceeding elements in the group graph pattern in which [the BIND clause] is used</q> [<a data-cite="SPARQL11-QUERY#variableScope">SPARQL11-QUERY, Section 18.2.1]</a>].</li>
        </ul>
      </section>

      <section>
        <h2>Expand Syntax Forms</h2>

        <p>The translation process starts with expanding <q>abbreviations for IRIs and triple patterns</q> [<a data-cite="SPARQL11-QUERY#sparqlExpandForms">SPARQL11-QUERY, Section 18.2.2.1</a>]. This step MUST be extended in two ways:</p>

        <ol>
          <li><div>
            <p>Abbreviations for <a>triple patterns</a> with <a>embedded triple patterns</a> MUST be expanded as if each <a>embedded triple pattern</a> was a <a>variable</a> (or an <a>RDF term</a>).

            <div class="example">
              For instance, the following syntax expression:
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src ;
                    prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src .
                <<?c a rdfs:Class>> prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
            </div>
          </div></li>
          <li><div>
            <p>Abbreviations for IRIs in all <a>embedded triple patterns</a> MUST be expanded.</p>

            <div class="example">
              For instance, the embedded triple pattern
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>>
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2000/01/rdf-schema#Class>>>
                -->
              </pre>
            </div>
          </div></li>
        </ol>
      </section>

      <section>
        <h2>Translate Property Path Patterns</h2>

        <p>The <a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">translation of property path patterns</a> has to be adjusted because the extended grammar allows for property path patterns whose subject or object is an <a>embedded triple pattern</a> (cf. <a href="#sparql-star-grammar"></a>).</p>

        <p>The translation as specified in the W3C specification distinguishes four cases. The first three of these cases do not require adjustment because they are taken care of either by recursion or by the adjusted translation of basic graph patterns (as defined in <a href="#translate-bgp"></a> below). However, the fourth case MUST be adjusted as follows.</p>

        <p>Let |X| |P| |Y| be a string that corresponds to the fourth case in [<a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">SPARQL11-QUERY, Section 18.2.2.4</a>]. Given the grammar introduced in <a href="#sparql-star-grammar"></a>, |X| and |Y| may be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, respectively (and |P| is a <a>property path expression</a>). The string |X| |P| |Y| is translated to the algebra expression `Path`(<var>X’</var>,|P|,<var>Y’</var>) where <var>X’</var> and <var>Y’</var> are the result of calling a function named `Lift` for |X| and |Y|, respectively. For some input string |Z| (such as |X| or |Y|) that can be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, the function `Lift` is defined as follows:</p>

        <ol id="lift">
          <li>If |Z| is an <a>embedded triple pattern</a> &lt;&lt;|S|,|P|,|O|&gt;&gt; then return the <a>SPARQL* triple pattern</a> (`Lift`(|S|, |P|, `Lift`(|O|));</li>
          <li>Otherwise, return |Z|.</li>
        </ol>
      </section>

      <section id="translate-bgp">
        <h2>Translate Basic Graph Patterns</h2>

        <p>After translating <a>property path patterns</a>, the translation process collects <q>any adjacent triple patterns [...] to form a basic graph pattern</q> [<a data-cite="SPARQL11-QUERY#sparqlTranslateBasicGraphPatterns">SPARQL11-QUERY, Section 18.2.2.5</a>]. This step has to be adjusted because <a>triple patterns</a> in the extended syntax may have an <a>embedded triple pattern</a> in their subject position or in their object position (or in both). To ensure that every result of this step is a <a>BGP*</a>, before adding a <a>triple pattern</a> to its corresponding collection, its subject and object MUST be replaced by the result of calling <a href="#lift">function `Lift`</a> for the subject and the object, respectively.</p>
      </section>

      <section id="translate-bind">
        <h2>Translate BIND Clauses with an Embedded Triple Pattern</h2>

        <p>The extended grammar in <a href="#sparql-star-grammar"></a> allows for BIND clauses with an <a>embedded triple pattern</a>. The translation of such a BIND clause to a SPARQL algebra expression requires a new algebra symbol:</p>

        <ul>
          <li>TR( <a>SPARQL* triple pattern</a>, <a>variable</a> )</li>
        </ul>

        <p>Note that this symbol corresponds to <a>SPARQL* expressions</a> of the form (`tp` AS `?v`).</p>

        <p>Then, any string of the form `BIND( T AS v )` with |T| being an <a>embedded triple pattern</a> (i.e., not a standard BIND expression) is translated to the algebra expression `TR`(<var>T’</var>, |v|) where <var>T’</var> is the result of the <a href="#lift">function `Lift`</a> for |T|.</p>

        <p>Notice, the translation of BIND clauses with an <a>embedded triple pattern</a> as defined in this section is used during <a data-cite="SPARQL11-QUERY#sparqlTranslateGraphPatterns">the translation of group graph patterns</a>. The case of BIND clauses with an <a>embedded triple pattern</a> is covered in this translation of group graph patterns by the last, “catch all other” `IF` statement (i.e., the `IF` statement with the condition `E is any other form`) and not by the `IF` statement for BIND clauses with an expression.</p>
      </section>
    </section>

    <section>
      <h2>Evaluation Semantics</h2>

      <p>TODO here the definitions of
        <dfn>SPARQL* expression</dfn>,
        <dfn>evaluation</dfn>...
      </p>

      <p>The SPARQL specification defines a function <q>eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G</q> [<a href="SPARQL11-QUERY#sparqlAlgebraEval">SPARQL11-QUERY, Section 18.6</a>]. Recall that the active graph |G| in the context of SPARQL* is an <a>RDF* graph</a>, and so is any other graph in dataset |D|. The definition of function eval is recursive; the two base cases of this definition for SPARQL* are given as follows:</p>

      <ul>
        <li>For any <a>BGP*</a> |B|, eval(D(|G|), |B|) = ⟦|B|⟧<sub>|G|</sub> (where ⟦|B|⟧<sub>|G|</sub> is the <a>evaluation</a> of |B| over <a>RDF* graph</a> |G|).</li>

        <li>For any algebra expression |E| of the form TR(|tp|, <var>?v</var>) where |tp| is a <a>SPARQL* triple pattern</a> and <var>?v</var> is a <a>variable</a> (as introduced <a href="#translate-bind"></a>>), eval(D(|G|), |E|) = ⟦(|tp| AS <var>?v</var>)⟧<sub>|G|</sub> (where ⟦(|tp| AS <var>?v</var>)⟧<sub>|G|</sub> is the <a>evaluation</a> of SPARQL* expression (|tp| AS <var>?v</var>) over <a>RDF* graph</a> |G|.</li>
      </ul>

      <div class="issue" data-number="8"></div>

      <p>For any other algebra expression, the SPARQL specification defines algebra operators [[SPARQL11-QUERY]]. These definitions can be extended naturally to operate over multisets of <a>SPARQL* solution mappings</a> (instead of ordinary <a>solution mappings</a>). Given this extension, the recursive steps of the definition of function eval for SPARQL* are the same as in the SPARQL specification.</p>
    </section>

    <section>
      <h2>Query Result Formats</h2>

      <p>TODO: brief introduction paragraph (including a note that result of a CONSTRUCT query or a DESCRIBE query can be serialized using <a href="#turtle-star">Turtle*</a>)</p>

      <section>
        <h2>SPARQL* Query Results JSON Format</h2>

        <div class="issue" data-number="13"></div>

      </section>

      <section>
        <h2>SPARQL* Query Results XML Format</h2>

        <div class="issue" data-number="12"></div>

      </section>
      
    </section>

  </section>

  <section>
    <h2>SPARQL* Update</h2>

    <div class="issue" data-number="14"></div>

  </section>

  <section>
    <h2>RDF* Semantics</h2>

    <p>In this section, we provide a model-theoretic semantics for RDF*, by extending the one defined in [[[RDF11-MT]]] [[RDF11-MT]].</p>

    <section>
      <h2>Definitions</h2>

      <p>An <dfn>RDF* simple interpretation</dfn> |I| is a structure consisting of:</p>
      <ol>
        <li>A non-empty set |IR| of resources, called the domain or universe of |I|.</li>
        <li>A set |IP|, called the set of properties of |I|.</li>
        <li>A mapping |IEXT| from |IP| into the powerset of |IR|×|IR| i.e. the set of sets of pairs (|x|,|y|) with |x| and |y| in |IR|.</li>
        <li>A mapping |IS| from <a>IRIs</a> into |IR|∪|IP|.</li>
        <li>A partial mapping |IL| from <a>literals</a> into |IR|.</li>
        <li>A partial mapping |IT| from <a>RDF* triples</a> into |IR|.</li>
        <li>A mapping |ITEXT| from codomain(|IT|) into |IR|×|IP|×|IR|.</li>
      </ol>

      <p>This definition is identical to the definition of <dfn data-cite="RDF11-MT#dfn-simple-interpretation">simple interpretation</dfn> [[RDF11-MT]] up to item 5 included. Items 6 and 7 extend it to support <a>RDF* triples</a>. As a consequence, any RDF <a>simple interpretation</a> can be considered as an <a>RDF* simple interpretation</a> with |IT|=|ITEXT|=∅.</p>

      <section>
        <h2>Semantic condition for ground graphs</h2>
        <p>We say that an <a>RDF* graph</a> is <dfn data-lt="ground RDF* graph">ground</dfn> if its set of <a>constituent terms</a> contains no <a>blank node</a>. This is a generalization of the notion of <a data-cite="RDF11-MT#dfn-ground">ground RDF graph</a> [[RDF11-MT]]. The denotation of a <a>ground RDF* graph</a> in an <a>RDF* simple interpretation</a> |I| is then given by the following rules, where the interpretation is also treated as a function from expressions (terms, triples and graphs) to elements of the universe and truth values:</p>

        <ul id="semantic-condition-ground-graphs">
          <li>if |E| is a <a>literal</a> then |I|(|E|) = |IL|(|E|)</li>
          <li>if |E| is an <a>IRI</a> then |I|(|E|) = |IS|(|E|)</li>
          <li>if |E| is an <a>embedded triple</a> then |I|(|E|) = |IT|(|E|)</li>
          <li>if |E| is an <a>asserted triple</a> (|s|,|p|,|o|) then |I|(|E|) = <ul>
            <li>true if |I|(|p|) ∈ |IP| and (|I|(|s|),|I|(|o|)) ∈ |IEXT|(|IP|(|p|))</li>
            <li>false otherwise
          </ul></li>
          <li>if |E| is an <a>RDF* graph</a> then then |I|(|E|) = true if<ul>
            <li>for every <a>RDF* triple</a> |t| ∈ |E|, |I|(|t|) = true, and</li>
            <li>for every <a>RDF* triple</a> |t| = (|s|,|p|,|o|) ∈ <a>constituents</a>(|E|), |ITEXT|(|IT|(|t|)) = (|I|(|s|), |I|(|p|), |I|(|o|))</li>
          </ul>otherwise |I|(|E|) = false</li>
        </ul>

        <p>Since |IL| and |IT| are partial mappings, |I|(|E|) may be undefined for some <a>literal</a> or <a>embedded triple</a> |E|. In that case, |E| has no semantic value in |I|, so any triple containing it will be false, hence any graph containing that triple will also be false.</p>

        <div class="note">
          The condition above extends the one defined in [[[RDF11-MT]]] in order to handle <a>embedded triples</a>, but does not differ from it when it comes to other kinds of <a>RDF terms</a>. As such, for the special case of a standard <a>RDF graphs</a> and standard <a>simple interpretation</a>, the condition above is equivalent to the original one.
        </div>
      </section>

      <section>
        <h2>Semantic condition with blank nodes</h2>

        <p>An invertible mapping from the set <a>blank nodes</a> into itself is called a <dfn>blank node renaming</dfn>. By extension, we define the application of a <a>blank node renaming</a> |R| to other <a>RDF* terms</a> and to <a>RDF* graphs</a> as follow:</p>

        <ul>
          <li>if |E| is an <a>IRI</a> or a <a>literal</a>, then |R|(|E|) = |E|</li>
          <li>if |E| is an <a>RDF* triple</a> (|s|,|p|,|o|), then |R|(|E|) = (|R|(|s|),|R|(|p|),|R|(|o|))</li>
          <li>if |E| is an <a>RDF* graph</a>, then |R|(|E|) = {|R|(|t|) for all |t| ∈ |E|} </li>
        </ul>

        <p>Suppose |I| is an <a>RDF* simple interpretation</a> and |A| is a mapping from a set of <a>blank nodes</a> to the universe |IR| of |I|. Define the mapping [|I|+|A|] of <a>RDF* terms</a> into |IR| to be |A| on blank nodes of the set, and |I| on any other term; and extend this mapping to <a>RDF* triples</a> and <a>RDF* graphs</a> using <a href="#semantic-condition-ground-graphs">the rules given above for ground graphs</a>. Then the denotation of any <a>RDF* graph</a> in |I| is given by:</p>

        <ul>
          <li>If |E| is an <a>RDF* graph</a>, |I|(|E|)=true if [|I|+|A|](|R|(|E|))=true<ul>
            <li>for some <a>blank node renaming</a> |R|, and</li>
            <li>for some mapping |A| from the set of <a>blank nodes</a> in <a>constituents</a>(|R|(|E|)) into |IR|</li>
          </ul>otherwise |I|(|E|)=false</li>
        </ul>

        <div class="note">
          For the special case of a standard <a>RDF graph</a> and an RDF <a>simple interpretation</a>, the condition above is equivalent to the one defined in [[[RDF11-MT]]], which only requires a mapping |A|, but no <a>blank node renaming</a>. Indeed, if the <a href="RDF11-MT#blank_nodes">original condition</a> holds, then the identity function can trivially be chosen for |R| to fulfill the condition above. Conversely, if the condition above holds with |R| and |A|, then the mapping |A|∘|R| can be used to fulfill the original condition.
        </div>
      </section>

      <section>
        <h2>Entailment</h2>

        <p>Following [[[RDF11-MT]]], we extend the notions of satisfiability and entailment. An <a>RDF* simple interpretation</a> <dfn data-lt="satisfiability">satisfies</dfn> |E| when |I|(|E|)=true. |E| is (simply) <dfn>satisfiable</dfn> when an <a>RDF* simple interpretation</a> exists which satisfies it, otherwise (simply) <dfn>unsatisfiable</dfn>. An <a>RDF* graph</a> |G| simply <dfn>entails</dfn> an <a>RDF* graph</a> H when every interpretation which satisfies |G| also satisfies |H|. If two <a>RDF* graphs</a> |G| and |H| each entail the other then they are logically <dfn>equivalent</dfn>.</p>

        <p>Any <a data-cite="RDF11-MT#dfn-semantic-extension">semantic extension</a> of RDF MAY be extended to RDF* by replacing the semantic conditions, the notion of satisfiability and the notion of entailment, defined in [[[RDF11-MT]]], by their corresponding extension defined above. This is notably the case for <a data-cite="RDF11-MT#D_entailment">Datatype entailment</a> and <a data-cite="RDF11-MT#rdfs_entailment">RDFS entailment</a>.</p>
      </section>
    </section>

    <section class="informative">
      <h2>Design Rationale</h2>

      <p>In this section, we discuss a number of desired features of RDF* semantics, in order to shed light on the design choices made in the previous section</p>

      <section>
        <h2>Quoting without asserting</h2>

        <p>RDF* must be able to quote a triple without asserting it, so that we can represent peoples' beliefs without endorsing them, or facts are no longer or not yet true. This is ensured by the fact that the semantic condition on <a>embedded triples</a> (introduced for in RDF*) is different from the one on <a>asserted triples</a> (inherited from RDF).</p>

        For example, the following graph:
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          :alice :believes << :bob :name "Charlie" >>.
          -->
        </pre>
        does <em>not entail</em> `:bob :name "Charlie"`,
        and the SPARQL* query below executed against the graph above would return no result.
        <pre data-transform="updateExample"
        data-content-type="application/x-sparql-star-query"
        class="nohighlight example"
        >
          <!--
          SELECT ?name { :bob :name ?name }
          -->
        </pre>
      </section>

      <section>
        <h2>Blank node scope</h2>

        <p><a>Blank nodes</a> in <a>embedded triples</a> have the same scope as blank nodes used in the <a>subject</a> or <a>object</a> position of <a>asserted triples</a> (usually the whole graph or the whole dataset in which they appear). This means that the same <a>blank node</a> identifier used in different <a>embedded triples</a>, or at different levels of nesting, will refer to the same thing.</p>

        <p>For example, in the following graph:</p>
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          :alice :knows _:x.
          :alice :believes << _:x :name "Charlie" >>.
          :alice :believes << _:x :workingFor :acme >>.
          -->
        </pre>
        <p>the three occurrence of `_:x` must refer to the same resource in every interpretation of the graph. In other words, it must be the same resource that Alice knows, that she believes is named "Charlie", and that she believes works for ACME.</p>
        <p>As a consequence, the following query will return `"Charlie"`:</p>
        <pre data-transform="updateExample"
          data-content-type="application/x-sparql-star-query"
          class="nohighlight example"
        >
          <!--
          SELECT ?name {
            :alice :knows ?x.
            :alice :believes << ?x :name ?name >>.
            :alice :believes << ?x :workingFor :acme >>.
          }
          -->
        </pre>
        <p>As another consequence, the following graph does <em>not entail</em> the graph above (because the graph below allows the resource known by Alice to be different from the one about which she has beliefs).</p>
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          :alice :knows _:y.
          :alice :believes << _:x :name "Charlie" >>.
          :alice :believes << _:x :workingFor :acme >>.
          -->
        </pre>

        <p>Formally, the second graph is satisfied by an interpretation where:</p>
        <ul>
          <li>|IS|: `:alice`→A, `:knows`→K, `:believes`→B, `:name`→N, `:workingFor`→W, `:acme`→M</li>
          <li>|IL|: `"Charlie"`→C
          <li>|IT|: `&lt;&lt; _:x :name "Charlie" &gt;&gt;`→T1, `&lt;&lt; _:x :workingFor :acme &gt;&gt;`→T2</li>
          <li>|IEXT|(K) = {(A,Y)}</li>
          <li>|IEXT|(B) = {(A,T1), (A,T2)}</li>
          <li>|ITEXT|(T1) = (X,N,C)</li>
          <li>|ITEXT|(T2) = (X,W,M)</li>
        </ul>
        <p>but this interpretation can not satisfy the first graph, because the mapping `A` must map `_:x` to both Y (to satisfy |IEXT|(K)) and to X (to satisfy |ITEXT|(T1) and |ITEXT|(T2)).</p>
      </section>

      <section id="referential-opacity">
        <h2>Referential opacity</h2>

        <p><a>Embedded triples</a> are referentially opaque, meaning that triples using different terms are considered different, even if their terms can be inferred to be synonyms. Although RDF* simple <a href="#entailment">entailment</a> has no mean to entail any kind of synonymy, it is possible in some <a data-cite="RDF11-MT#dfn-semantic-extension">semantic extensions</a>, such as OWL [[OWL2-RDF-BASED-SEMANTICS]].

        <p>A well known example is the <a href="https://www.w3.org/2001/12/attributions/#superman">superman problem</a>:</p>

        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          :loisLane :believes << :superman :can :fly >>.
          :superman owl:sameAs :clarkKent.
          :superman :can :fly.
          -->
        </pre>

        <p>Intuitively: this graph states that Superman and Clark Kent are the same person, so if Superman can fly, then it follows that Clark Kent can as well. So, under OWL2-entailment, this graph entails `:clarkKent :can :fly`. However, Lois Lane <em>does not know</em> that Superman and Clark Kent are the same person. So from her point of view, the two triples are not equivalent, and she can believe one without believing the other.</p>

        <p>Referential opacity is ensured by differentiating the <em>intension</em> of embedded triples (represented by the |IT| mapping) from their extension (represented by |ITEXT|). Since |IT| is based solely on the syntax of triples, two syntactically different triples can always have different intentions, even if they are semantically equivalent (i.e. their extensions are identical).</p>
      </section>

      <section id="bnode-identifiers-not-significant">
        <h2>Blank node identifiers are not significant</h2>
        <p>In standard RDF, renaming a blank node does not change the semantics of a graph (provided that the new name was not already in use in that graph). This is ensured by the fact that RDF <a>simple interpretations</a> do not depend on <a>blank node</a> identifiers at all. In RDF*, however, because of the need for <a href="#referential-opacity">referential opacity</a>, the |IT| mapping does depend on the <a>blank node</a> identifiers used in the <a>embedded triple</a>. This is why the notion of <a>satisfiability</a> in RDF additionally relies on a <a>blank node renaming</a>.</p>

        <p>Consider the following graph:</p>
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          :alice :believes << _:x :name "Charlie" >>.
          -->
        </pre>
        <p>Every interpretation satisfying this graph must have, for some A, B, C, N, T and X:</p>
        <ul>
          <li>|IS|: `:alice`→A, `:believes`→B, `:name`→N</li>
          <li>|IL|: `"Charlie"`→C
          <li>|IT|: `&lt;&lt; _:x :name "Charlie" &gt;&gt;`→T</li>
          <li>|IEXT|(B) = {(A,T)}</li>
          <li>|ITEXT|(T) = (X,N,C)</li>
        </ul>
        <p>Any such interpretation can be shown to also satisfy the graph below:</p>
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          :alice :believes << _:y :name "Charlie" >>.
          -->
        </pre>
        <p>For this, we must chose |R| such that |R|(`_:y`)=`_:x`, and |A| such that |A|(`_:x`)=X.</p>
      </section>

    </section>

  </section>

  <section class="appendix" id="issue-summary">
    <!-- A list of issues will magically appear here -->
  </section>
</body>
</html>

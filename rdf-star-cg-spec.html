<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>RDF* and SPARQL*</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
   // All config options at https://respec.org/docs/
   var respecConfig = {
      specStatus: "CG-DRAFT",
      editors: [
        {
          "name": "Olaf Hartig",
          "url": "https://olafhartig.de/",
          "company": "Linköping University",
          "orcid": "0000-0002-1741-2090",
          "companyURL": "https://liu.se/",
        },{
          "name":       "Pierre-Antoine Champin",
          "url":        "http://champin.net/",
          "company":    "ERCIM",
          "companyURL": "https://www.ercim.eu/",
          "w3cid":      42931,
          "orcid": "0000-0001-7046-4474",
        },
      ],
      authors: [
      {
          "name": "Dörthe Arndt",
          "company": "Ghent University",
        },
        {
          "name": "Bryan Thompson",
          "company": "Amazon",
        },
        {
          "name": "Jeen Broekstra",
          "company": "metaphacts",
        },
      ],
      github: "w3c/rdf-star",
      shortName: "rdf-star",
      group: "rdf-dev",
      xref: ["RDF11-CONCEPTS", "SPARQL11-QUERY", "RDF11-MT"],
      maxTocLevel: 2,
    };
  </script>
  <style>
    /* copied from TR/turtle, and adapted for SPARQL rules */
    .grammar td { font-family: monospace; vertical-align: top; }
    .grammar-literal, .token { color: gray;}
    .grammar_comment { color: #A52A2A; font-style: italic; }
  </style>
  <script>
    /* copied from JSON-LD specs */
    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(reindent(unComment(doc, content)));
    }

    function _esc(s) {
      return s.replace(/&/g,'&amp;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;');
    }

    function reindent(text) {
      // TODO: use trimEnd when Edge supports it
      const lines = text.trimRight().split("\n");
      while (lines.length && !lines[0].trim()) {
        lines.shift();
      }
      const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
      const leastIndent = Math.min(...indents);
      return lines.map(s => s.slice(leastIndent)).join("\n");
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
        .replace(/-->/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }
  </script>
</head>
<body>
  <section id="abstract">
    <p>TODO</p>
  </section>
  <section id="sotd">
  </section>

  <section id="introduction">
    <h1>Introduction</h1>

    <section class="informative">
      <h2>Background and Motivation</h2>

      <p>TODO, citing [[RDF-STAR-FOUNDATION]]</p>
    </section>

    <section class="informative">
      <h2>Overview</h2>

      <p>TODO (the purpose of this section will be to provide an informal introduction to the approach for practitioners)</p>
      <p>The syntax of RDF is defined in two layers:</p>
      <ul>
        <li>the <dfn>abstract syntax</dfn>, which is the conceptual data model of RDF, and</li>
        <li>multiple <dfn data-cite="RDF11-CONCEPTS#dfn-concrete-rdf-syntax" data-lt="concrete syntax|concrete RDF syntax|concrete RDF syntaxes">concrete syntaxes</dfn> (such as RDF/XML [[RDF-SYNTAX-GRAMMAR]], Turtle [[TURTLE]] or JSON-LD [[JSON-LD11]]), which are data formats used to serialize the abstract syntax into files or over the wire.</li>
      </ul>
      <p>Similarly, this document defines the <a>abstract syntax</a> of RDF* in <a href="#concepts"></a>, and one <a>concrete syntax</a> based on Turtle [[TURTLE]] in <a href="#turtle-star"></a>.</p>

      <p>TODO list the prefix definitions implicitly used in all examples</p>
    </section>

    <section id="conformance">
      <div class=issue data-number="3"></div>
    </section>

  </section>

  <section id="concepts">
    <h2>Concepts and Abstract Syntax</h2>

    <p>An <dfn data-lt="graph">RDF* graph</dfn> is a set of <a>RDF* triples</a>.</p>

    <p>An <dfn data-lt="triple">RDF* triple</dfn> is a 3-tuple defined recursively as follows:</p>
    <ul>
      <li>any <a>RDF triple</a> is an <a>RDF* triple</a>;</li>
      <li>if |t| and <var>t'</var> are <a>RDF* triples</a>, |s| is an <a>IRI</a> or a <a>blank node</a>, |p| is an <a>IRI</a>, |o| is an <a>IRI</a>, a <a>blank node</a> or a <a>literal</a>, then (|t|, |p|, |o|), (|s|, |p|, |t|) and (|t|, |p|, <var>t'</var>) are <a>RDF* triples</a>.</li>
    </ul>

    <p>As for <a>RDF triples</a>, we call the 3 components of an <a>RDF* triple</a> its <dfn data-cite="RDF11-CONCEPTS#dfn-subject">subject</dfn>, <dfn data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</dfn> and <dfn data-cite="RDF11-CONCEPTS#dfn-object">object</dfn>, respectively. From the definitions above, it follows that any <a>RDF graph</a> is also an <a>RDF* graph</a>. Note also that, by definition, an RDF* triple cannot contain itself and cannot be nested infinitely.</p>

    <!-- the paragraph below is totally uninformative, but the "foreign" dfn are required-->
    <p style="display: none">The definition relies on the notions of
      <dfn data-cite="RDF11-CONCEPTS#dfn-iri">IRI</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-literal">literal</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-triple">RDF triple</dfn>,
      and <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-graph">RDF graph</dfn>,
      introduced by [[[RDF11-CONCEPTS]]] [[RDF11-CONCEPTS]].
    </p>

    <p><a>IRIs</a>, <a>literals</a>, <a>blank nodes</a> and <a>RDF* triples</a> are collectively known as <dfn>RDF* terms</dfn>.</p>

    <p>For every <a>RDF* triple</a> <var>t</var>, we define its <dfn data-lt="constituent">constituent terms</dfn> (or simply constituents) as the set containing its <a>subject</a>, its <a>predicate</a>, its <a>object</a>, plus all the <a>constituent terms</a> of its <a>subject</a> and/or its <a>object</a> if they are themselves <a>RDF* triples</a>. By extension, we define the <a>constituent terms</a> of an <a>RDF* graph</a> to be the union set of the <a>constituent terms</a> of all its triples.</p>

    <div class="example">
      Consider the following <a>RDF* triple</a> (represented in Turtle*):
      <pre data-transform="updateExample"
        data-content-type="text/x-turtle-star"
        class="nohighlight example"
      >
        <!--
        << _:a :name "Alice" >> :statedBy :bob.
        -->
      </pre>
      Its set of <a>constituent terms</a> comprises the <a>IRIs</a> `:name`, `:statedBy`, `:bob`, the <a>blank node</a> `_:a`, the <a>literal</a> `"Alice"`, and the <a>triple</a> `&lt;&lt; _:a :name "Alice" >>`.
    </div>

    <p>An <a>RDF* triple</a> used as the <a>subject</a> or <a>object</a> of another <a>RDF* triple</a> is called an <dfn data-lt="embedded">embedded triple</dfn>. An <a>RDF* triple</a> that is an element of an <a>RDF* graph</a> is called an <dfn data-lt="asserted">asserted triple</dfn>. Note that, in a given <a>RDF* graph</a>, the same <a>triple</a> MAY be both <a>embedded</a> and <a>asserted</a>.</p>

    <p>An <dfn data-lt="dataset">RDF* dataset</dfn> is a collection of <a>RDF* graphs</a>, and comprises:</p>

    <ul>
      <li>Exactly one <dfn data-cite="RDF11-CONCEPTS#dfn-default-graph">default graph</dfn>, being an <a>RDF* graph</a>. The <a>default graph</a> does not have a name and MAY be empty.</li>
      <li>Zero or more <dfn data-cite="RDF11-CONCEPTS#dfn-named-graph">named graphs</dfn>. Each <a>named graph</a> is a pair consisting of either an <a>IRI</a> or a <a>blank node</a> (called the <dfn data-cite="RDF11-CONCEPTS#dfn-graph-name">graph name</dfn>), and an <a>RDF* graph</a>. <a>Graph names</a> are unique within an <a>RDF* dataset</a>.</li>
    </ul>

    <p>Again, this definition is an extension of the notion of <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-dataset">RDF dataset</dfn>, hence it follows that any <a>RDF dataset</a> is also an <a>RDF* dataset</a>.</p>
  </section>

  <section id="turtle-star">
    <h2>Turtle*</h2>
    <p>In this section, we present Turtle*, an extension of the Turtle format [[TURTLE]] allowing the representation of <a>RDF* graphs</a>. For the sake of conciseness, we only describe here the differences between Turtle* and Turtle.</p>

    <section id="turtle-star-grammar">
      <h2>Grammar</h2>
      <p>Turtle* is defined to follow the <a data-cite="TURTLE#h3_sec-grammar-grammar">same grammar</a> as Turtle, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions having the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="grammar-production-objectList">
          <td>[8]</td>
          <td>`objectList`</td>
          <td>::=</td>
          <td>
            <a href="#grammar-production-object">object</a>
            <a href="#grammar-production-annotation">annotation</a>`?`
            `(`
            <code class="grammar-literal">','</code>
            <a href="#grammar-production-object">object</a>
            <a href="#grammar-production-annotation">annotation</a>`?`
            `)*`
          </td>
        </tr>
        <tr id="grammar-production-subject">
          <td>[10]</td>
          <td>`subject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-object">
          <td>[12]</td>
          <td>`object`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a  data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a data-cite="TURTLE#grammar-production-blankNodePropertyList">blankNodePropertyList</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embTriple">
          <td>[27]</td>
          <td>`embTriple`</td>
          <td>::=</td>
          <td>
            <code class="grammar-literal">'&lt;&lt;'</code>
            <a href="#grammar-production-embSubject">embSubject</a>
            <a data-cite="TURTLE#grammar-production-verb">verb</a>
            <a href="#grammar-production-embObject">embObject</a>
            <code class="grammar-literal">'&gt;&gt;'</code>
          </td>
        </tr>
        <tr id="grammar-production-embSubject">
          <td>[28]</td>
          <td>`embSubject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embObject">
          <td>[29]</td>
          <td>`embObject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-annotation">
          <td>[31]</td>
          <td>`annotation`</td>
          <td>::=</td>
          <td>
            <code class="grammar-literal">'{|'</code>
            <a  data-cite="TURTLE#grammar-production-predicateObjectList">predicateObjectList</a>
            <code class="grammar-literal">'|}'</code>
          </td>
        </tr>
      </table>

      <p class="note">The changes are that <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-object">`object`</a> productions have been extended to accept <a>embedded triples</a>, which are described by the new productions <a href="#grammar-production-embTriple">27</a> to <a href="#grammar-production-embObject">29</a>. Note that <a>embedded triples</a> accept a more restricted range of <a>subject</a> and <a>object</a> expressions than <a>asserted triples</a>. Additionally, the <a href="#grammar-production-objectList">`objectList`</a> production now accepts an optional <a href="#grammar-production-annotation">annotation</a> after each object.</p>

      <div class="issue" data-number="9"></div>
    </section>

    <section>
      <h2>Parsing</h2>
      <p>A Turtle* parser is similar to a Turtle parser as defined in <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], with an additional item in its state :</p>
      <ul>
        <li id="curObject"><a>RDF* Term</a> |curObject| — The |curObject| is bound to the <a href="#grammar-production-embObject">`embObject`</a> production.</li>
      </ul>
      <p>Additionally, the <a data-cite="TURTLE#curSubject">|curSubject|</a> can be bound to any <a>RDF* term</a> (including an <a>embedded triple</a>).</p>

      <p>A Turtle* document defines an <a>RDF* graph</a> composed of a set of <a>RDF* triples</a>. The <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-embSubject">`embSubject`</a> productions set the |curSubject|. The <a data-cite="TURTLE#grammar-production-verb">`verb`</a> production sets the <a data-cite="TURTLE#curPredicate">|curPredicate|</a>. The <a href="#grammar-production-object">`object`</a> and <a href="#grammar-production-embObject">`embObject`</a> productions set the |curObject|. Finishing the <a href="#grammar-production-object">`object`</a> production, an <a>RDF* triple</a> |curSubject| |curPredicate| |curObject| is generated and added to the <a>RDF* graph</a>.</p>

      <p>Beginning the <a href="#grammar-production-embTriple">`embTriple`</a> production records the |curSubject| and |curPredicate|. Finishing the <a href="#grammar-production-embTriple">`embTriple`</a> production yields the <a>RDF* triple</a> |curSubject| |curPredicate| |curObject| and restores the recorded values of |curSubject| and |curPredicate|.</p>

      <p>Beginning the <a href="#grammar-production-annotation">`annotation`</a> production records the |curSubject| and |curPredicate|, and sets the |curSubject| to the <a>RDF* triple</a> |curSubject| |curPredicate| |curObject|. Finishing the <a href="#grammar-production-annotation">`annotation`</a> production restores the recorded values of |curSubject| and |curPredicate|.</p>

      <p>All other productions MUST be handled as specified by <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], while still applying the changes above recursively.</p>
    </section>

    <section class="informative">
      <h2>Other Concrete Syntaxes</h2>

      <p>While this document specifies only one <a>concrete syntax</a>, nothing prevents other <a>concrete syntaxes</a> of RDF* from being proposed. In particular, other existing <a>concrete syntaxes</a> for RDF, such as RDF/XML [[RDF-SYNTAX-GRAMMAR]], could be extended to support RDF*. In particular, the N-Triples syntax [[N-TRIPLES]] being a subset of Turtle, an appropriate subset of Turtle* could be defined to extend N-Triples accordingly.</p>
    </section>

  </section>

  <section>
    <h2>SPARQL* Query Language</h2>

    <p>This Section introduces SPARQL*, which is an RDF*-aware extension of the RDF query language SPARQL [[SPARQL11-QUERY]]; i.e., SPARQL* can be used to query RDF* graphs.</p>

    <section>
      <h2>Initial Definitions</h2>

      <p>In the following, we introduce a number of SPARQL*-specific definitions, which rely on the following notions, defined in [[[SPARQL11-QUERY]]] [[SPARQL11-QUERY]]: <dfn data-cite="SPARQL11-QUERY#defn_RDFTerm">RDF term</dfn>, <dfn data-cite="SPARQL11-QUERY#defn_QueryVariable" data-lt="variable">query variable</dfn>, <dfn data-cite="SPARQL11-QUERY#defn_TriplePattern">triple pattern</dfn>,
      <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathPattern">property path pattern</dfn>,
      <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathExpr">property path expression</dfn>,
      and <dfn data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</dfn>.</p>

      <p>A <dfn data-lt="triple-star-pattern">SPARQL* triple pattern</dfn> is a 3-tuple that is defined recursively as follows:</p>
      <ol>
        <li>Every SPARQL <a>triple pattern</a> is a SPARQL* triple pattern;
        <li>If |t| and <var>t'</var> are SPARQL* triple patterns, |x| is an <a>RDF term</a> or a <a>query variable</a>, and |p| is an <a>IRI</a> or a <a>query variable</a>, then (|t|,&nbsp;|p|,&nbsp;|x|), (|x|,&nbsp;|p|,&nbsp;|t|), and (|t|,&nbsp;|p|,&nbsp;<var>t'</var>) are SPARQL* triple patterns.
      </ol>

      <p>As for <a>RDF* triples</a>, a <a>SPARQL* triple pattern</a> MUST NOT contain itself.</p>

      <p>A <dfn data-lt="bgp-star|BGP*">SPARQL* basic graph pattern</dfn> (<abbr title="Basic Graph Pattern">BGP</abbr>*) is a set of <a>SPARQL* triple patterns</a>.</p>

      <p>A <dfn data-lt="ppp-star">SPARQL* property path pattern</dfn> is a 3-tuple (|s|,|p|,|o|) where</p>
      <ul>
        <li>|s| is either an <a>RDF term</a>, a <a>query variable</a>, or a <a>SPARQL* triple pattern</a>,
        <li>|p| is a <a>property path expression</a>, and
        <li>|o| is either an <a>RDF term</a>, a <a>query variable</a>, or a <a>SPARQL* triple pattern</a>.
      </ul>

      <div class="issue" data-number="7"></div>

      <p>A <dfn data-lt="solution-star-mapping">SPARQL* solution mapping</dfn> μ is a partial function from the set of all <a>query variables</a> to the set of all <a>RDF* terms</a>.
      The domain of μ, denoted by dom(μ), is the set of <a>query variables</a> for which μ is defined.</p>

      <p class="note">The notion of a <a>SPARQL* solution mapping</a> extends the notion of a standard SPARQL <a>solution mapping</a>; that is, every SPARQL <a>solution mapping</a> is a <a>SPARQL* solution mapping</a>. However, in contrast to SPARQL <a>solution mappings</a>, <a>SPARQL* solution mappings</a> may map <a>variables</a> also to <a>RDF* triples</a>.</p>

      <p>All notions related to SPARQL solution mappings carry over naturally to SPARQL* solution mappings. In particular, the definition of <dfn data-cite="SPARQL11-QUERY#defn_algCompatibleMapping">compatibility</dfn> extends naturally to SPARQL* solution mappings: two <a>SPARQL* solution mappings</a> μ<sub>1</sub> and μ<sub>2</sub> are compatible if, for every variable v that is both in dom(μ<sub>1</sub>) and in dom(μ<sub>2</sub>), μ<sub>1</sub>(v) and μ<sub>2</sub>(v) are the same <a>RDF* term</a>.
      In this case, μ<sub>1</sub> ∪ μ<sub>2</sub> is also a SPARQL* solution mapping.
      Moreover, for any SPARQL* solution mapping&nbsp;μ we write card[Ω](μ) to denote the cardinality of μ in a multiset Ω of such mappings.
      Finally, given a <a>BGP*</a>&nbsp;|B| and a SPARQL* solution mapping&nbsp;μ, we write μ(|B|) to denote the result of replacing every variable&nbsp;|v| in |B| for which μ is defined with μ(v).
      </p>

      <p>Next, we aim to carry over the notion of <a data-cite="SPARQL11-QUERY#BGPsparql">solutions for BGPs</a> to <a>BGP*</a>. To this end, we first define an auxiliary concept that carries over the notion of an
      <a data-cite="RDF11-MT#definst">RDF instance mapping</a> [[RDF11-MT]] to RDF*.</p>

      <p>An <dfn data-lt="rdf-star-instance-mapping">RDF* instance mapping</dfn>&nbsp;σ is a partial function from the set of all <a>blank nodes</a> to the set of all <a>RDF* terms</a>.
      The domain of&nbsp;σ, denoted by dom(σ), is the set of <a>blank nodes</a> for which σ is defined.</p>

      <p>Similar to the corresponding notation for solution mappings, for an RDF* instance mapping&nbsp;σ and a BGP*&nbsp;|B| we write σ(|B|) to denote the result of replacing every blank node&nbsp;|b| in |B| for which σ is defined with σ(b).</p>

      <p>Now we are ready to define the notion of solution for BGP*.</p>

      <p>Given a <a>BGP*</a>&nbsp;|B| and an <a>RDF* graph</a>&nbsp;|G|, a <a>SPARQL* solution mapping</a>&nbsp;μ is a <dfn data-lt="bgp-star-solution">solution for the BGP*</dfn>&nbsp;|B| <b>over</b>&nbsp;|G| if it has the following two properties</p>
      <ul>
        <li>dom(μ) is equivalent to the set of query variables in&nbsp;|B|, and
        <li>there exists an <a>RDF* instance mapping</a>&nbsp;σ such that dom(σ) is equivalent to the set of blank nodes in&nbsp;|B| and μ(σ(|B|)) is a subgraph of |G|.
      </ul>

    </section>

    <section id="sparql-star-grammar">
      <h2>Grammar</h2>

      <p>SPARQL* is defined to follow the <a data-cite="SPARQL11-QUERY#sparqlGrammar">same grammar</a> as SPARQL, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions having the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="rBind">
          <td>[60]</td>
          <td>`Bind`</td>
          <td>::=</td>
          <td>
            <code class="token">'BIND'</code>
            <code class="token">'('</code>
            (
              <a data-cite="SPARQL11-QUERY#rExpression">Expression</a> `|`
              <a href="#rEmbTP">EmbTP</a>
            )
            <code class="token">'AS'</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            <code class="token">')'</code>
          </td>
        </tr>
          <tr id="rTriplesSameSubject">
          <td>[75]</td>
          <td>`TriplesSameSubject`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListNotEmpty">PropertyListNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyList">PropertyList</a>
        </td>
        <tr id="rObject">
          <td>[80]</td>
          <td>`Object`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rGraphNode">GraphNode</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rTriplesSameSubjectPath">
          <td>[81]</td>
          <td>`TriplesSameSubjectPath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPath">PropertyListPath</a>
          </td>
        </tr>
        <tr id="rGraphNodePath">
          <td>[105]</td>
          <td>`GraphNodePath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a> `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNodePath">TriplesNodePath</a> `|`
          </td>
        </tr>
        <tr id="rEmbTP">
          <td>[174]</td>
          <td>`EmbTP`</td>
          <td>::=</td>
          <td>
            <code class="token">'&lt;&lt;'</code>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <a data-cite="SPARQL11-QUERY#rVerb">Verb</a>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <code class="token">'&gt;&gt;'</code>
          </td>
        </tr>
        <tr id="rEmbSubjectOrObject">
          <td>[175]</td>
          <td>`EmbSubjectOrObject`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rBlankNode">BlankNode</a> `|`
            <a data-cite="SPARQL11-QUERY#riri">iri</a> `|`
            <a data-cite="SPARQL11-QUERY#rRDFLiteral">RDFLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rNumericLiteral">NumericLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rBooleanLiteral">BooleanLiteral</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rVarOrTermOrEmbTP">
          <td>[176]</td>
          <td>`VarOrTermOrEmbTP`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rGraphTerm">GraphTerm</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
      </table>

      <p>
        This introduces a notation for <dfn>embedded triple patterns</dfn>
        (productions <a href="#rEmbTP">[174]</a> and following),
        which is similar to the one defined for <a>embedded triples</a> in <a href="#turtle-star"></a>,
        but accepting also <a>variables</a>.
        These <a>embedded triple patterns</a> are allowed in the subject
        (<a href="#rTriplesSameSubject">[75]</a>, <a href="#rTriplesSameSubjectPath">[81]</a>)
        and object
        (<a href="#rObject">[80]</a>, <a href="#rGraphNodePath">[105]</a>)
        positions of <a>SPARQL* triple patterns</a>,
        as well as in BIND statements
        (<a href="#rBind">[60]</a>).
      </p>

      <div class="issue" data-number="6"></div>

    </section>

    <section>
      <h2>Translation to the Algebra</h2>

      <p>Based on the SPARQL grammar, the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> [<a data-cite="SPARQL11-QUERY#sparqlQuery">SPARQL11-QUERY, Section 18.2</a>].  This process must be adjusted to consider the extended grammar introduced <a href="#sparql-star-grammar">above</a>. In the following, any step of the conversion process that requires adjustment is discussed.</p>

      <section>
        <h2>Variable Scope</h2>

        <p>As a basis of the translation, the SPARQL specification introduces a notion of <a data-cite="SPARQL11-QUERY#variableScope">in-scope variables</a>. To cover the new syntax elements introduced in <a href="#sparql-star-grammar"></a> this notion MUST be extended as follows.</p>

        <ul>
          <li>A <a>variable</a> is in-scope of a <a>BGP*</a> |B| if the <a>variable</a> occurs in |B|, which includes an occurrence in any <a>embedded triple pattern</a> in |B| (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a <a>property path pattern</a> if the variable occurs in that pattern, which includes an occurrence in any embedded triple pattern in the pattern (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a BIND clause of the form `BIND ( T AS v )` (where |T| is an <a>embedded triple pattern</a>) if the variable is variable |v| or the variable occurs in the <a>embedded triple pattern</a> |T|. As for standard BIND clauses with expressions, variable |v| must <q>not [be] in-scope from the preceeding elements in the group graph pattern in which [the BIND clause] is used</q> [<a data-cite="SPARQL11-QUERY#variableScope">SPARQL11-QUERY, Section 18.2.1]</a>].</li>
        </ul>
      </section>

      <section>
        <h2>Expand Syntax Forms</h2>

        <p>The translation process starts with expanding <q>abbreviations for IRIs and triple patterns</q> [<a data-cite="SPARQL11-QUERY#sparqlExpandForms">SPARQL11-QUERY, Section 18.2.2.1</a>]. This step MUST be extended in two ways:</p>

        <ol>
          <li><div>
            <p>Abbreviations for <a>triple patterns</a> with <a>embedded triple patterns</a> MUST be expanded as if each <a>embedded triple pattern</a> was a <a>variable</a> (or an <a>RDF term</a>).

            <div class="example">
              For instance, the following syntax expression:
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src ;
                    prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src .
                <<?c a rdfs:Class>> prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
            </div>
          </div></li>
          <li><div>
            <p>Abbreviations for IRIs in all <a>embedded triple patterns</a> MUST be expanded.</p>

            <div class="example">
              For instance, the embedded triple pattern
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>>
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2000/01/rdf-schema#Class>>>
                -->
              </pre>
            </div>
          </div></li>
        </ol>
      </section>

      <section>
        <h2>Translate Property Path Patterns</h2>

        <p>The <a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">translation of property path patterns</a> has to be adjusted because the extended grammar allows for <a>SPARQL* property path patterns</a> whose subject or object is a <a>SPARQL* triple pattern</a>.</p>

        <p>The translation as specified in the W3C specification distinguishes four cases. The first three of these cases do not require adjustment because they are taken care of either by recursion or by the adjusted translation of basic graph patterns (as defined in <a href="#translate-bgp"></a> below). However, the fourth case MUST be adjusted as follows.</p>

        <p>Let |X| |P| |Y| be a string that corresponds to the fourth case in [<a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">SPARQL11-QUERY, Section 18.2.2.4</a>]. Given the grammar introduced in <a href="#sparql-star-grammar"></a>, |X| and |Y| may be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, respectively (and |P| is a <a>property path expression</a>). The string |X| |P| |Y| is translated to the algebra expression `Path`(<var>X’</var>,|P|,<var>Y’</var>) where <var>X’</var> and <var>Y’</var> are the result of calling a function named `Lift` for |X| and |Y|, respectively. For some input string |Z| (such as |X| or |Y|) that can be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, the function `Lift` is defined recursively as follows:</p>

        <ol id="lift">
          <li>If |Z| is an <a>embedded triple pattern</a> &lt;&lt;|S|,|P|,|O|&gt;&gt; then return the <a>SPARQL* triple pattern</a> (`Lift`(|S|), |P|, `Lift`(|O|));</li>
          <li>Otherwise, return |Z|.</li>
        </ol>

        <div class="note">
          The purpose of this translation step is to convert any property path pattern as can be written based on the extended grammar for SPARQL* (cf. <a href="#sparql-star-grammar"></a>) into a <a>SPARQL* property path pattern</a> as considered in the algebra. To this end, the function `Lift` translates every <a>embedded triple pattern</a> as can be written in the SPARQL* syntax into a <a>SPARQL* triple pattern</a>.
        </div>
      </section>

      <section id="translate-bgp">
        <h2>Translate Basic Graph Patterns</h2>

        <p>After translating <a>property path patterns</a>, the translation process collects <q>any adjacent triple patterns [...] to form a basic graph pattern</q> [<a data-cite="SPARQL11-QUERY#sparqlTranslateBasicGraphPatterns">SPARQL11-QUERY, Section 18.2.2.5</a>]. This step has to be adjusted because <a>triple patterns</a> in the extended syntax may have an <a>embedded triple pattern</a> in their subject position or in their object position (or in both). To ensure that every result of this step is a <a>BGP*</a>, before adding a <a>triple pattern</a> to its corresponding collection, its subject and object MUST be replaced by the result of calling <a href="#lift">function `Lift`</a> for the subject and the object, respectively.</p>
      </section>

      <section id="translate-bind">
        <h2>Translate BIND Clauses with an Embedded Triple Pattern</h2>

        <p>The extended grammar in <a href="#sparql-star-grammar"></a> allows for BIND clauses with an <a>embedded triple pattern</a>. The translation of such a BIND clause to a SPARQL algebra expression requires a new algebra symbol:</p>

        <ul>
          <li>TR( <a>SPARQL* triple pattern</a>, <a>variable</a> )</li>
        </ul>

        <p>Then, any string of the form `BIND( T AS v )` with |T| being an <a>embedded triple pattern</a> (i.e., not a standard BIND expression) is translated to the algebra expression `TR`(<var>T’</var>, |v|) where <var>T’</var> is the result of the <a href="#lift">function `Lift`</a> for |T|.</p>

        <p>Notice, the translation of BIND clauses with an <a>embedded triple pattern</a> as defined in this section is used during <a data-cite="SPARQL11-QUERY#sparqlTranslateGraphPatterns">the translation of group graph patterns</a>. The case of BIND clauses with an <a>embedded triple pattern</a> is covered in this translation of group graph patterns by the last, “catch all other” `IF` statement (i.e., the `IF` statement with the condition `E is any other form`) and not by the `IF` statement for BIND clauses with an expression.</p>
      </section>
    </section>

    <section>
      <h2>Evaluation Semantics</h2>

      <p>The SPARQL specification defines a function <q>eval(|D|(|G|), algebra expression) as the evaluation of an algebra expression with respect to a dataset |D| having active graph |G|</q> [<a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">SPARQL11-QUERY, Section 18.6</a>]. Recall that the dataset |D| in the context of SPARQL* is an <a>RDF* dataset</a> and, thus, the active graph |G| is an <a>RDF* graph</a>, and so is any other graph in dataset |D|. The definition of the <a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">eval</a> function is recursive; the two base cases of this definition for SPARQL* are given as follows:</p>

      <ol>
        <li>For every <a>BGP*</a> |B|, eval(|D|(|G|), |B|) is a multiset Ω that consists of all <a>SPARQL* solution mappings</a> that are a <a>solution for the BGP*</a>&nbsp;|B| over&nbsp;|G|. For every such mapping&nbsp;μ, card[Ω](μ) is the number of distinct <a>RDF* instance mappings</a>&nbsp;σ such that dom(σ) is equivalent to the set of blank nodes in&nbsp;|B| and μ(σ(|B|)) is a subgraph of |G|. (For any SPARQL* solution mapping&nbsp;μ' that is <em>not</em> a solution for&nbsp;|B| over&nbsp;|G|, we have that card[Ω](μ')=0; i.e., μ' is not in Ω.)</li>

        <li>For any algebra expression |E| of the form TR(|tp|, <var>?v</var>) where |tp| is a <a>SPARQL* triple pattern</a> and <var>?v</var> is a <a>variable</a> (as introduced in <a href="#translate-bind"></a>), eval(|D|(|G|), |E|) is a multiset Ω that consists of as many <a>SPARQL* solution mappings</a> as there are solution mappings in Ω', where Ω'=eval(|D|(|G|),{|tp|}), such that for every μ' in Ω' there exists a μ in Ω that has the following four properties:
          <ol type="i">
            <li>dom(μ) = dom(μ') ∪ {<var>?v</var>}</li>
            <li>μ and μ' are compatible</li>
            <li>μ(<var>?v</var>) = μ'(|tp|)</li>
            <li>card[Ω](μ) = card[Ω'](μ')</li>
          </ol>
        </li>
      </ol>

      <p>For any other algebra expression, the SPARQL specification defines algebra operators [[SPARQL11-QUERY]]. These definitions can be extended naturally to operate over multisets of <a>SPARQL* solution mappings</a> (instead of ordinary <a>solution mappings</a>). Given this extension, the recursive steps of the definition of the <a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">eval</a> function for SPARQL* are the same as in the SPARQL specification.</p>
    </section>

    <section>
      <h2>Query Result Formats</h2>

      <p>In SPARQL, queries can take four forms: <em>SELECT</em>, <em>CONSTRUCT</em>, <em>DESCRIBE</em>, and <em>ASK</em> - see <a data-cite="SPARQL11-QUERY#QueryForms">SPARQL1.1 Query, Section 16</a> [[SPARQL11-QUERY]]. The first of these returns a <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionSequence">sequence of solution mappings</a> that contain variable bindings. The second and third both return an RDF graph, and the last returns a boolean value.
      </p>
      <p>The result of the <em>ASK</em> query form is not changed by the introduction of RDF*, and the result of the <em>CONSTRUCT</em> and <em>DESCRIBE</em> forms can be represented by <a href="#turtle-star">Turtle*</a>. However, since the <em>SELECT</em> form deals with returning individual RDF terms, the specific serialization formats for representing such query results need to be extended so that the new <a>embedded</a> triple RDF term can be represented. In this section, we propose extensions for the two most common formats for this purpose: [[[sparql11-results-json]]], and [[[rdf-sparql-XMLres]]].</p>

      <div class="issue" data-number="43"></div>

      <section>
        <h2>SPARQL* Query Results JSON Format</h2>
        <p>
        The result of a SPARQL SELECT query is serialized in JSON as defined in [[[sparql11-results-json]]], which specifies a JSON representation of variable bindings to RDF terms (see [<a data-cite="sparql11-results-json#select-results">sparql11-results-json, Section 3.2</a>]). To accomodate the new RDF term for <a>embedded</a> triples that RDF* introduces, the table of RDF term JSON representations in  <a data-cite="sparql11-results-json#select-encode-terms">sparql11-results-json, Section 3.2.2</a> is extended with the following entry:
        </p>
        <dl>
            <dt>An <a>embedded</a> triple with subject RDF term `S`, predicate RDF term `P` and object RDF term `O`</dt>
            <dd>
              <pre>
                {
                  "type": "triple",
                  "value": {
                     "subject": S,
                     "predicate": P,
                     "object": O
                  }
                }
              </pre>
              where `S`, `P` and `O` are encoded using the same format, recursively.
            </dd>
          </dl>
        <div class="example">
            Consider the following RDF term, an <a>embedded</a> triple in Turtle* syntax:
          <pre data-transform="updateExample"
            data-content-type="text/x-turtle-star"
            class="nohighlight example"
          >
            <!--
            << <http://example.org/alice> <http://example.org/name> "Alice" >>
            -->
          </pre>
          This term is represented in JSON as follows:
          <pre class="example">
                {
                  "type": "triple",
                  "value": {
                     "subject": {
                        "type": "uri",
                        "value" "http://example.org/alice"
                     },
                     "predicate": {
                        "type": "uri",
                        "value" "http://example.org/name"
                     },
                     "object": {
                        "type": "literal",
                        "value" "Alice",
                        "datatype": "http://www.w3.org/2001/XMLSchema#string"
                     },
                  }
                }
          </pre>
        </div>
      <!-- <div class="issue" data-number="13"></div> -->
      </section>

      <section>
        <h2>SPARQL* Query Results XML Format</h2>
       <p>
        The result of a SPARQL SELECT query is serialized in XML as defined in [[[rdf-sparql-XMLres]]]. This format proposes an XML representation of variable bindings to RDF terms.
       </p>
       <p>To accomodate the new RDF term for <a>embedded</a> triples that RDF* introduces, the list of RDF terms and their XML representations in [<a href="rdf-sparql-XMLres#results">rdf-sparql-XMLres, Section 2.3.1</a>] is extended as follows:
        </p>
        <p>
        <dl>
            <dt>An <a>embedded</a> triple with subject term `S`, predicate term `P`, and object term `O`</dt>
          <dd>
            <pre data-transform="updateExample" class="xml">
              <!--
              <binding>
                <triple>
                  <subject>S</subject>
                  <predicate>P</predicate>
                  <object>O</object>
                </triple>
              </binding>
              -->
            </pre>
            where `S`, `P` and `O` are encoded recursively, using the same format, without the enclosing `&lt;binding&gt;` tag.
          </dd>
        </dl>
        <div class="example">
            Consider the following RDF term, an <a>embedded</a> triple in Turtle* syntax:
          <pre data-transform="updateExample"
            data-content-type="text/x-turtle-star"
            class="nohighlight example"
          >
            <!--
            << <http://example.org/alice> <http://example.org/name> "Alice" >>
            -->
          </pre>
          This term is represented in XML as follows:
          <pre data-transform="updateExample" class="xml example">
            <!--
            <triple>
                <subject>
                    <uri>http://example.org/alice</uri>
                </subject>
                <predicate>
                    <uri>http://example.org/name</uri>
                </predicate>
                <object>
                    <literal datatype='http://www.w3.org/2001/XMLSchema#string'>Alice</literal>
                </object>
            </triple>
            -->
          </pre>
        </div>

        <!-- <div class="issue" data-number="12"></div> -->

      </section>

    </section>

  </section>
    </section>

  </section>

  <section>
    <h2>SPARQL* Update</h2>

    <div class="issue" data-number="14"></div>

  </section>

  <section>
    <h2>RDF* Semantics</h2>

    <p>In this section, we provide a model-theoretic semantics for RDF*, by extending the one defined in [[[RDF11-MT]]] [[RDF11-MT]].</p>

    <section>
      <h2>Definitions</h2>

      <p>An <a>RDF* triple</a> is said to be <dfn data-lt="ground RDF* triple|ground RDF* graph|ground triple|ground graph">ground</dfn> if it has no <a>blank node</a> in its <a>constituent terms</a>. An <a>RDF* graph</a> is <a>ground</a> if all its triples are <a>ground</a>. This definition generalizes the notion of <a data-cite="RDF11-MT#dfn-ground">ground RDF graph</a>. <a>IRIs</a>, <a>literals</a> and <a>ground RDF* terms</a> are collectively known as <dfn>ground RDF* terms</dfn>.</p>

      <p>An <dfn>RDF* simple interpretation</dfn> |I| is a structure consisting of:</p>
      <ol>
        <li>A non-empty set |IR| of resources, called the domain or universe of |I|.</li>
        <li>A set |IP|, called the set of properties of |I|.</li>
        <li>A mapping |IEXT| from |IP| into the powerset of |IR|×|IR| i.e. the set of sets of pairs (|x|,|y|) with |x| and |y| in |IR|.</li>
        <li>A mapping |IS| from <a>IRIs</a> into |IR|∪|IP|.</li>
        <li>A partial mapping |IL| from <a>literals</a> into |IR|.</li>
        <li>A partial mapping |IT| from <a>ground RDF* triples</a> into |IR|, such that for any two <a>triples</a> (|s1|,|p1|,|o1|) and (|s2|,|p2|,|o2|), |IT|(|s1|,|p1|,|o1|)=|IT|(|s2|,|p2|,|o2|) implies |IG|(|s1|)=|IG|(|s2|), |IG|(|p1|)=|IG|(|p2|) and |IG|(|o1|)=|IG|(|o2|), where |IG|=|IS|∪|IL|∪|IT|.</li>
      </ol>

      <p>This definition is identical to the definition of <dfn data-cite="RDF11-MT#dfn-simple-interpretation">simple interpretation</dfn> [[RDF11-MT]] up to item 5 included. Item 6 extends it to support <a>RDF* triples</a>. Any RDF <a>simple interpretation</a> can be considered as an <a>RDF* simple interpretation</a> with |IT|=∅.</p>

      <section>
        <h2>Semantic condition for ground graphs</h2>
        <p>The denotation of a <a>ground RDF* graph</a> in an <a>RDF* simple interpretation</a> |I| is then given by the following rules, where the interpretation is also treated as a function from expressions (terms, triples and graphs) to elements of the universe and truth values:</p>

        <ul id="semantic-condition-ground-graphs">
          <li>if |E| is a <a>literal</a> then |I|(|E|) = |IL|(|E|)</li>
          <li>if |E| is an <a>IRI</a> then |I|(|E|) = |IS|(|E|)</li>
          <li>if |E| is a <a>ground RDF* triple</a> then |I|(|E|) = |IT|(|E|)</li>
          <li>if |E| is an <a>RDF* graph</a> then |I|(|E|) =<ul>
            <li>true if for every <a>asserted triple</a> (|s|,|p|,|o|) ∈ |E|, (|I|(|s|),|I|(|o|)) ∈ |IEXT|(|I|(|p|))</li>
            <li>false otherwise</li>
          </ul>
        </ul>

        <p>Since |IL| and |IT| are partial mappings, |I|(|E|) may be undefined for some <a>literal</a> or <a>triple</a> |E|. In that case, |E| has no semantic value in |I|, so any <a>asserted triple</a> having E as <a>subject</a> or <a>object</a> it will fail to satisfy the condition above, hence any <a>graph</a> containing such <a>asserted triple</a> will be false.</p>

        <div class="note">
          In the <a data-cite="RDF11-MT#semantic-condition-for-ground-graphs">original condition for simple entailment</a> [[RDF11-MT]], the denotation of an <a>RDF triple</a> is a boolean, while above we define the denotation of an <a>RDF* triple</a> to be an element of the universe. However, the denotation of any <a>RDF graph</a> is always the same under the original condition and the condition above. Therefore, the condition above can be considered as an extension of the original one to support any <a>RDF* graph</a>.
        </div>
      </section>

      <section>
        <h2>Semantic condition with blank nodes</h2>
        
        <p>Given an <a>RDF* graph</a> |E|, we call the <dfn data-abbr="ebn">embedded blank nodes</dfn> of |E| the set of <a>blank nodes</a> appearing in <a>subject</a> or <a>object</a> position of some <a>embedded triple</a> in |E|; we call the <dfn data-abbr="obn">open blank nodes</dfn> of |E| all the other blank nodes appearing in |E|.</p>

        <p>A mapping from a set <a>blank nodes</a> into a set of <a>ground RDF* terms</a> is called a <dfn>grounding function</dfn>. We define the extended application of a <a>grounding function</a> <var>Γ</var> to other <a>RDF* terms</a> and to <a>RDF* graphs</a> as follows:</p>

        <ul>
          <li>if |E| is a <a>blank node</a> then <var>Γ</var>*(|E|) = <var>Γ</var>(|E|) if it is defined, |E| otherwise</li>
          <li>if |E| is an <a>IRI</a> or a <a>literal</a>, then <var>Γ</var>*(|E|) = |E|</li>
          <li>if |E| is an <a>RDF* triple</a> (|s|,|p|,|o|), then <var>Γ</var>*(|E|) = (<var>Γ</var>*(|s|),<var>Γ</var>*(|p|),<var>Γ</var>*(|o|))</li>
          <li>if |E| is an <a>RDF* graph</a>, then <var>Γ</var>*(|E|) = {<var>Γ</var>*(|t|) for all |t| ∈ |E|} </li>
        </ul>

        <p>Suppose |I| is an <a>RDF* simple interpretation</a> and |A| is a mapping from a set of <a>blank nodes</a> to the universe |IR| of |I|. Define the mapping [|I|+|A|] of <a>RDF* terms</a> into |IR| to be |A| on blank nodes of the set, and |I| on any other term; and extend this mapping to <a>RDF* triples</a> and <a>RDF* graphs</a> using <a href="#semantic-condition-ground-graphs">the rules given above for ground graphs</a>. Then the denotation of any <a>RDF* graph</a> in |I| is given by:</p>

        <ul>
          <li>If |E| is an <a>RDF* graph</a>, |I|(|E|)=<ul>
            <li>true if there exists
              <ul>
                <li>a mapping |A| from <a>obn</a>(|E|) into |IR|, and</li>
                <li>a <a>grounding function</a> <var>Γ</var> from <a>ebn</a>(|E|) into <a>ground RDF* terms</a></li>
              </ul>
              such that [|I|+|A|](<var>Γ</var>*(|E|))=true
            </li>
            <li>
              false otherwise
            </li>
          </ul></li>
        </ul>

        <div class="note">
          For the special case of a standard <a>RDF graph</a> and an RDF <a>simple interpretation</a>, the condition above is equivalent to the one defined in [[[RDF11-MT]]], which only requires a mapping |A|, but no <a>grounding function</a>. Indeed, since <a>RDF graphs</a> have no <a>embedded triples</a>, the empty mapping is the only possible choice for <var>Γ</var>, and <var>Γ</var>* maps the graph to itself.
        </div>
      </section>

      <section>
        <h2>Entailment</h2>

        <p>Following [[[RDF11-MT]]], we extend the notions of satisfiability and entailment. An <a>RDF* simple interpretation</a> <dfn data-lt="satisfiability">satisfies</dfn> |E| when |I|(|E|)=true. |E| is (simply) <dfn>satisfiable</dfn> when an <a>RDF* simple interpretation</a> exists which satisfies it, otherwise (simply) <dfn>unsatisfiable</dfn>. An <a>RDF* graph</a> |G| simply <dfn>entails</dfn> an <a>RDF* graph</a> H when every interpretation which satisfies |G| also satisfies |H|. If two <a>RDF* graphs</a> |G| and |H| each entail the other then they are logically <dfn>equivalent</dfn>.</p>

        <p>Any <a data-cite="RDF11-MT#dfn-semantic-extension">semantic extension</a> of RDF MAY be extended to RDF* by replacing the semantic conditions, the notion of satisfiability and the notion of entailment, defined in [[[RDF11-MT]]], by their corresponding extension defined above. This is notably the case for <a data-cite="RDF11-MT#D_entailment">Datatype entailment</a> and <a data-cite="RDF11-MT#rdfs_entailment">RDFS entailment</a>.</p>
      </section>
    </section>

    <section class="informative">
      <h2>Design Rationale</h2>

      <p>In this section, we discuss a number of desired features of RDF* semantics in order to shed light on the design choices made in the previous section</p>

      <section>
        <h2>Quoting without asserting</h2>

        <p>RDF* must be able to quote a triple without asserting it, so that we can represent peoples' beliefs or claims without endorsing them, or represent facts that are no longer or not yet true. This is ensured by the fact that only <a>asserted triples</a> are considered to determine if the denotation of a graph is true or false.</p>

        For example, the following graph:
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          << :alice foaf:knows :bob >> dc:creator :alice.
          -->
        </pre>
        does <em>not entail</em> `:alice foaf:knows :bob`,
        and the SPARQL* query below executed against the graph above would return no result.
        <pre data-transform="updateExample"
        data-content-type="application/x-sparql-star-query"
        class="nohighlight example"
        >
          <!--
          SELECT ?who { :alice foaf:knows ?who }
          -->
        </pre>
      </section>

      <section id="referential-opacity">
        <h2>Referential opacity</h2>

        <p><a>Embedded triples</a> are referentially opaque, meaning that triples using different terms can be considered different, even if their terms can be inferred to be synonyms. Although RDF* simple <a href="#entailment">entailment</a> has no means to entail any kind of synonymy, it is possible in some <a data-cite="RDF11-MT#dfn-semantic-extension">semantic extensions</a>, such as OWL [[OWL2-RDF-BASED-SEMANTICS]].

        <p>A well known example is the <a href="https://www.w3.org/2001/12/attributions/#superman">superman problem</a>:</p>

        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
        >
          <!--
          :loisLane :believes << :superman :can :fly >>.
          :superman owl:sameAs :clarkKent.
          :superman :can :fly.
          -->
        </pre>

        <p>Intuitively: this graph states that Superman and Clark Kent are the same person, so if Superman can fly, then it follows that Clark Kent can as well. So, under OWL2-entailment, this graph entails `:clarkKent :can :fly`. However, Lois Lane <em>does not know</em> that Superman and Clark Kent are the same person. So from her point of view, the two triples are not equivalent, and she can believe one without believing the other.</p>

        <p>Referential opacity is ensured by differentiating the <em>intension</em> of embedded triples (represented by the |IT| mapping) from their extension (the denotations of their subject, predicate and object). Since |IT| is based solely on the syntax of triples, two syntactically different triples can always have different intentions, even if their subjects, predicates and objects are semantically equivalent.</p>

        <p>On the other hand, all triples with the same intension are required to have the same extension. So if two RDF* triples denote the same resource T, their subjects, predicates and objects, respectively, are constrained to also denote the same thing.</p>
      </section>

      <section>
        <h2>Blank node scope</h2>

        <p><a>Blank nodes</a> in <a>embedded triples</a> have the same scope as blank nodes used in the <a>subject</a> or <a>object</a> position of <a>asserted triples</a> (usually the whole graph or the whole dataset in which they appear). This means that the same <a>blank node</a> identifier used in different <a>embedded triples</a>, or at different levels of nesting, will refer to the same thing.</p>

        <p>For example, in the following graph:</p>
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
          id="bnode-scope-ex1"
        >
          <!--
          :alice :knows _:x.
          << _:x :name "Bob" >> dc:creator :alice.
          << _:x :workingFor :acme >> dc:creator :alice.
          -->
        </pre>
        <p>the three occurrence of `_:x` must refer to the same resource in every interpretation of the graph. In other words, it must be the same resource that Alice knows, that she claims is named "Bob", and that she claims works for ACME.</p>
        <p>As a consequence, the following query will return `"Bob"`:</p>
        <pre data-transform="updateExample"
          data-content-type="application/x-sparql-star-query"
          class="nohighlight example"
        >
          <!--
          SELECT ?name {
            :alice :knows ?x.
            << ?x :name ?name >> dc:creator :alice.
            << ?x :workingFor :acme >> dc:creator :alice.
          }
          -->
        </pre>
        <p>As another consequence, the following graph does <em>not entail</em> the graph above (because the graph below allows the resource known by Alice to be different from the one about which she makes claims).</p>
        <pre data-transform="updateExample"
          data-content-type="text/x-turtle-star"
          class="nohighlight example"
          id="bnode-scope-ex2"
        >
          <!--
          :alice :knows _:y.
          << _:x :name "Bob" >> dc:creator :alice.
          << _:x :workingFor :acme >> dc:creator :alice.
          -->
        </pre>

        <p>Formally, the <a href="#bnode-scope-ex2">second graph</a> is satisfied by an interpretation having:</p>
        <ul>
          <li>|IS|: `:alice`→A, `:knows`→K, `dc:creator`→C, `:bob`→B</li>
          <li>|IT|: `&lt;&lt; :bob :name "Bob" &gt;&gt;`→T1, `&lt;&lt; :bob :workingFor :acme &gt;&gt;`→T2</li>
          <li>|IEXT|(K) = {(A,Y)}</li>
          <li>|IEXT|(C) = {(T1, A), (T2, A)}</li>
        </ul>
        <p>with Γ: `_:x`→`:bob`, and A: `_:y`→Y. But this interpretation can not satisfy <a href="#bnode-scope-ex1">the first graph</a>, because it would require a <a>grounding function</a> Γ' such that</p>
        <ul>
          <li>I(Γ'(`_:x`)) = Y in order to satisfy the first triple,</li>
          <li>Γ'(`_:x`) = `:bob` in order to satisfy the second and third triple,</li>
          <li>and both can not be true at the same time in the interpretation above.</li>
        </ul>
      </section>

      <section id="interpolation-lemma">
        <h2>Interpolation lemma</h2>

        <p>The <a data-cite="RDF11-MT#dfn-interpolation">interpolation lemma</a> [[RDF11-MT]] states that an RDF graph G simply entails an RDF graph E if and only if a subgraph of G is an <a data-cite="RDF11-MT#dfn-instance">instance</a> of E. Intuitively, this means that all graphs simply entailed by G can be constructed by:</p>

        <ul>
          <li>removing triples,</li>
          <li>replacing a term with a fresh blank node,</li>
          <li>splitting a blank node into two (or more) fresh blank nodes.</li>
        </ul>

        <p>A design goal of the RDF* semantics was to preserve that property.</p>

        <p class="issue">We didn't prove it yet...</p>
      </section>

    </section>

  </section>

  <section class="appendix">
    <h2>Historical remarks</h2>

    <section class="appendix">
      <h2>SA-mode and PG-mode</h2>

      <p>A lot of discussions on the <a href="https://lists.w3.org/Archives/Public/public-rdf-star/">RDF* mailing list</a> and <a href="https://github.com/w3c/rdf-star">GitHub repository</a> refer to SA-mode and PG-mode. Those abbreviations stand for "Separate Assertion mode" and "Property Graph mode". They originate in the fact that different versions of RDF* have been published over the years, with different designs. In PG-mode, any <a>embedded triple</a> was also considered <a>asserted</a>. SA-mode, on the other hand, allowed the use of <a>embedded triples</a> without those triples being automatically <a>asserted</a>, requiring that they be <a>asserted</a> separately when that was intended. SA-mode was more flexible, but induced redundancy in the use-cases that PG-mode was designed to address.</p>

      <p>The notion of <a href="#grammar-production-annotation">annotations</a> in the <a href="#turtle-star">Turtle*</a> syntax was introduced to remove the need for different modes. Rather than interpret the same syntax differently in each mode, which would have caused interoperability problems and required a switch for those modes, it was decided to provide a different syntax for each use case.</p>

      <ul>
        <li>The <code>&lt;&lt; ... &gt;&gt;</code> syntax represents a triple that is <a>embedded</a> without being <a>asserted</a>, satisfying the need formerly filled by SA-mode.</li>
        <li>The <code>:a :b :c {| :p :o ... |}</code> annotation syntax creates triples where the subject is an <a>embedded</a> version of the triple <a>asserted</a> just before the annotation (here, <code>:a :b :c</code>), without the need to repeat it, satisfying the need formerly filled by PG-mode.</li>
      </ul>
    </section>

  </section>

  <section class="appendix" id="issue-summary">
    <!-- A list of issues will magically appear here -->
  </section>
</body>
</html>
